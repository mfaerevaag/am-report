%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../report"
%%% End:

% Motivation

New programming languages are coming into existence at a very rapid pace. Tools
for creating languages are in abundance, and even the beginning student of
computer science will most likely posses the knowledge to use them. When
languages become pass\'e or fundamental shortcomings are discovered, the
prevalent solution seems to be the creation of new and improved languages
instead of updating the existing. All of this has resulted in hundreds, if not
thousands, of available languages in a myriad of styles and paradigms for just
as many different purposes.

The world of language paradigms has become something of a religious matter for
many. Some swear by the functional approach, others by object orientation and
some insist on procedural languages, the rest on something in between. Each
require distinct and often very complex implementations that are inherently
difficult to optimize and evolve as the feature sets expand. Static or dynamic
typing is another question that divides people that of like pineapple on
pizza; strong arguments exist for both and it often comes down to a matter of
taste and preference.

Intrinsic to a language is a platform on which to be executed, be it a desktop
computer, cell phone, embedded device or essentially any other digital
device. Historically, languages where developed to be used on a single platform,
often written for a particular processor architecture, but nowadays only the
most domain specific languages can make due with that. Any language that desires
widespread adaptation must work on a multitude of devices, and not only are
there scores of architectures on the market, they are also very different in
terms of execution models and what technical primitives they provide.

Altogether language and platform diversity has grown beyond what most would have
believed when the first programmable machines appeared. That is why abstract
machines are becoming increasingly relevant to modern computer science.

In brief, an abstract machine relieves language creators of the burden of
architecture specific implementation. By providing a unified platform they
abstract away the underlying hardware specifics and can provide a higher level
of expressiveness than the bare-metal counterpart.

There are many abstract machines available today, and several are industrial
strength systems that are in use on billions of devices. What they generally
lack however, is flexibility in terms of language support. Usually they are
designed with a specific language, or family or languages, in mind which
obviously comes at the cost of adaptability by other languages. Emerging
paradigms such as dynamic and functional\footnote{Functional languages have been
  around for a long time, but are becoming increasingly popular} languages are
not well suited for the currently available abstract machines.

Having written a compiler for a functional language\footnote{In the course
  ``02122 Software Technology Project F14'' at DTU Compute} we are aware of the
issues faced by compiling code to traditional platforms, and have felt the need
for something better.

\subsection{The Multi-Paradigm Abstract Machine}

In response to the issues of today's available systems, the main ambition of
this project is to provide an abstract machine that is well suited for a
multitude of programming languages of different paradigms. Our system exposes
low level primitives that are relevant for system programming while being
efficient, expressive and secure enough as a higher level programming
environment.

To facilitate the above, an instruction set has been defined that covers the
requirements of many language paradigms in a solid, compact fashion with the
support of a corresponding execution model.

The instruction set and execution model have been implemented in the abstract
machine that we have named \thename{}.

\subsection{Status of the Implementation}

The \thename{} specification is an extensive document which covers a lot of
features. We have focused on implementing a subset of the specification that
enabled us to run simple programs and perform some benchmarking tests. Thus, the
full specification as is found in Appendix~\ref{sec:appendix:spec} is not
implemented. The Design chapter (Section~\ref{sec:design}) presents a lot of
knowledge both for abstract machines in general and specific to \thename{}, not
all of which is implemented. However, everything presented in Implementation
chapter (Section~\ref{sec:implementation}) has been developed unless otherwise
noted.

\subsection{Structure of the report}

To provide the foundational knowledge required to satisfy the ambition of the
project, Section~\ref{sec:background} describes what components make up an
abstract machine, and what existing solutions there are along with their
shortcomings. Section~\ref{sec:design} presents the design of the abstract
machine as well as the defined instruction set and a detailed explanation of the
problems we believe it solves. Section~\ref{sec:implementation} describe the
actual implementation of the machine and how we have dealt with various issues
through process.

Section~\ref{sec:evaluation} evaluates the status of the project and presents
some code analysis as well as benchmarking data.

Related work from which we have drawn inspiration is presented in
Section~\ref{sec:related-work} and finally Section~\ref{sec:project-management}
describe how we have managed the project, both technically and personally.

Throughout the report we use specific fonts for denoting \code{code} and
\instr{instruction} related names and snippets.
