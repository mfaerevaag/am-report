\subsubsection{Control Flow}
\label{sec:implementation:instr:control-flow}

At its core control flow is about changing the program counter of an executing
thread. The program counter, also known as the instruction pointer, is an
unsigned integral value representing an address in the byte code where the
machine will start parsing the next instruction. Instructions can change the
value of the program counter during execution which is the basis of all control
flow instructions, including branching and sub-routine calls.

The program counter is implemented as a field on the thread state and since the
thread state is the fundamental argument to all instruction functions, it is
trivial to change the program counter at any time. Because the byte code
programs are byte \textit{addressed} and most instructions span several bytes,
it is possible to set the program counter to a byte that is in the middle of an
instruction, which would lead to unpredictable unwanted behavior. Assemblers
usually use named labels that mark specific locations in assembly code and are
converted to actual addresses when assembled into binary format. It could also
be a task of the byte code verifier to assert that addresses always point to the
beginning of an instruction (as described in
Section~\ref{sec:separate-components:verifier:branch}).

Branching is the most fundamental control flow operation and is implemented
simply by setting the executing thread's program counter directly. Certain
checks are made to verify that a given address is a legal branch target,
detailed in Section~\ref{sec:impl:instr}.

Sub-routines are essentially implemented in the exact same way as branching
operations but with the addition of an activation element being pushed to the
stack. The activation element contains the address of the call site which is
used to set the program counter back when a return instruction is executed. In
addition to being on the stack, pointers to activation elements are saved as a
linked list in the thread state making it possible to retrieve its information
without having to search through the stack. Among others, it is used to check
whether the program counter is exceeding the address bounds of the current
sub-routine, which will result in an implicit return. %TODO: er det rigtigt?


\subsubsection{Prefixes and Suffixes}

Instructions can be prefixed or suffixed to invoke special behavior. TODO.

The {\tt noOverflow} prefix will enabled the machine to throw exceptions if
overflow occurs when executing the following instruction. This might for
instance be desired when executing arithmetic instruction, to ensure that the
arithmetic operation does not induce overflow which could induce unwanted
behavior.

Overflow is detected differently for different arithmetic operations and operand
types. This is required as different as types have different maximum and minimum
values. We will briefly explain the challenge of handling overflow in different
scenarios and how \thename{} currently, and imperfectly, tackles them.

Looking at how to detect overflow when doing arithmetic operations on {\em
  signed integer} operands, we have to take the size of the the operands' type
into account. For instance, an {\tt Int8} can only represent integer numbers in
the rage of -128 to 127. Knowing the type's maximum and minimum value, we can
deduce whether the operation will induce over- or underflow on operand $a$ and
$b$. In the case where the operation is addition, we check if operand $b$ is
larger than zero {\em and} operand $a$ is lesser than the sum of the type's
maximum value and $b$'s inverse. This can be denoted in the following
mathematical formula:
\label{eq:overflow}
\begin{equation}
  overflow = (b > 0) \wedge (a > max - b)
\end{equation}

In a similar fashion we can detect underflow by:
\begin{equation}
  underflow = (b < 0) \wedge (a < min - b)
\end{equation}

If the operation is subtraction, we just change the plus operator to minus, in
the two equations. In the case of multiplication we use division, etc.

For unsigned integers the case is a little simpler, as the operand cannot be
negative. Therefore, when doing addition, underflow can per definition not
occur:
\begin{equation}
  a + b > 0, \qquad when\ a > 0, b > 0
\end{equation}

For substitution, we only needs to check if the $b$ operand is greater
than $a$, which will result in a negative number, thus inducing underflow.
\begin{equation}
  a - b < 0, \qquad when\ a > 0, b > a
\end{equation}

These fairly simple solutions has shown through tests, to work well where the
operand precision is not {\tt Int64} or {\tt UInt64}. The reason for this is
that all overflow check function promote each operand to an {\tt int64\_t} or
{\tt uint64\_t}, which prevents overflow of all operands with lower
precision. In the case of 64-bit integers, there is a risk of the check it self
to overflow. More precisely, $a < min - b$ will overflow if $b$ is
positive. There is not good solution for this, other than to use a higher
precision number for the tests. As C does not have any built-in data types of
larger precision, one would have to use multi-precision numbers which would
require some time to implement. We have chosen to note the short comings of the
current solution and focus our attention else where (TODO).

Both
GCC~\footnote{\url{https://gcc.gnu.org/onlinedocs/gcc/Integer-Overflow-Builtins.html}}
and
Clang~\footnote{http://clang.llvm.org/docs/LanguageExtensions.html\#checked-arithmetic-builtins}
has built-in functions for doing integer arithmetic while also detecting
overflow. GCC's implementation (TODO: maybe also Clang) does this by converting
the two operands into infinite precision numbers, where after doing the the
operation on the promoted operands. The result is then cast to the original
precision. If the casted result does not equal the infinite precision result,
overflow has occurred, which is indicated by the functions return value. We have
chosen to not use these to hold the implementation as library independent as
possible TODO.

Detecting overflow for floating-point precision numbers is somewhat more
challenging, due to the more complex nature of its implementation. The C
Standard Library has built-in constants for finding the a float's maximum value;
{\tt FLT\_MIN} and {\tt FLT\_MAX} for single precision, {\tt DBL\_MIN} and {\tt
  DBL\_MAX} for double precision. These could in theory be used in the same
fashion as above, creating an efficient solution, given that we could do
built-in arithmetic operations on them. This is unfortunately, as {\tt FLT\_MAX
  - 1}, for instance, is regarded as undefined behavior and will on most
platforms equal to {\tt FLT\_MAX}. Inducing undefined behavior when trying to
deduce whether an instruction is safe, renders it's point moot.

We have therefor chosen to use a simple, but also sub optimal, solution. When,
for instance, adding two floats together that should produce overflow, the
resulting value will become equal to {\tt FLT\_MAX} (in the case of single
precision). We therefor check whether the result of each operation either equals
the maximum or minimum value for the given precision. In cases where an
operation equals exactly the maximum or minimum value, an overflow exception
will be thrown, even though under- or overflow will not have occurred. TODO:
need more comment?

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../report"
%%% End:
