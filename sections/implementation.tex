\subsection{Tools and Languages}

We have implemented \thename{} in the C programming language, more specifically
using the C99 standard with GNU extensions by use of GCC\footnote{The GNU
  Compiler Collection: \url{https://gcc.gnu.org}}. There are both pros and cons
of using a relatively low-level language (as compared to other available
languages), but we found that the benefits outweighed the disadvantages.

First of all C is extremely portable; GCC is available on \textit{a lot} of
architectures, and all modern operating systems ship with a C compiler which
essentially is all that is required to build \thename{} for a new platform. The
standard libraries and architecture specific functions available differ with
each machine and device, so we aim at relying on as few external libraries as
possible and provide wrappers for the ones we use so that the implementation can
be ported quickly.

Secondly we do not want to rely on a garbage collector provided by languages
like C++ and Java. We need to full control over where each bit of data is
stored, mostly for performance reasons both in terms of memory footprint and
execution speed.

Third, speed is of the essence and C is notoriously fast, given that the code is
well-written.

There are however downsides to using C. Because we are not veterans of C and due
to its low-level nature it is inherently more difficult to develop features that
could be implemented in a few lines of code in a higher-level language, and
memory has to be tracked meticulously to prevent memory leaks. We have found
that it is a great exercise for becoming proficient with programming in general
because it provides us with knowledge of the mechanisms that lie behind concepts
that are generally taken for granted.

For debugging we use gdb via GNU Emacs\footnote{GNU Emacs:
  \url{http://www.gnu.org/software/emacs}} and for analyzing memory usage and
fixing memory leaks we use the Valgrind instrumentation tool\footnote{Valgrind:
  \url{http://valgrind.org}}.

The code is extensively documented using Doxygen\footnote{Doxygen:
  \url{http://www.stack.nl/~dimitri/doxygen}} style comments.

\textbf{Note:} The code snippets presented in the following sections does not
always correspond directly with the code found in the actual
implementation. They carry the gist of what we want to communicate but generally
avoids unnecessary and redundant information not relevant to the individual
cases.

\subsection{Core Infrastructure}

The infrastructure of \thename{} is the code that lays the basis for interaction
between the individual parts of the system. It is a collection of machinery
which hand control back and forth between each other, such as the instruction
cycle, thread management and exception handling. Besides the machine's exposed
exception handling system there is an internal error handling mechanism which
allows errors within the machine to be handled as gracefully possible.

The machine is separated into modules, %TODO-S1

The abstract machine state, implemented as the \code{am\_state} struct, contains
data that is generally available in a machine-wide context. We say ``generally''
because some parts of the system are by design ignorant of their context. A
symbol table, for instance, is not aware of which thread is using it, and
instructions do not know of the abstract machine state. The \code{am\_state}


thread
instructions
stack
types
gc interface
symtab, strtab, ttable


\subsubsection{File Reading}
The first thing the machine does upon start up is to load various parts of the
executable file into memory. %TODO

\subsubsection{Instruction Cycle}

The fundamental means of operation in the machine is the execution of
instructions parsed and interpreted from byte code. Each thread runs their own
cycle, the essence of which is shown in
Listing~\ref{lst:implementation:instruction-cycle}

\begin{lstlisting}[%
  caption={Pseudo representation of the instruction cycle},%
  label={lst:implementation:instruction-cycle}]
while (thread is running) {
  fetch opcode
  fetch potential arguments
  execute instruction corresponding to opcode
  update program counter
}
\end{lstlisting}

Opcodes and any potential arguments are read from the code section of the
executable.

\subsubsection{Debugging}
Logging macros
Debug functions (print_stack)

% vm initialization
% instruction cycle
% memory layout (stack per thread, heap area, code area)
% thread

% Very general architecture (theres a vm, a file reader, instruction codes, etc)
% What's in the VM state and Thread state?
% How code bytes are handled
% Instruction cycles
% Internal error handling
% Logging/debugging facilities
% Graceful exits / clean up
% Command line arguments

\subsection{Stacks}
\input{sections/implementation-stack}

\subsection{Execution Model}
\thename{} uses a simple calling convention that

\subsection{Heap Objects}

\begin{figure}[H]
  \centering
  \input{figures/heap-object-layout}
  \caption{Heap object memory layout}
\end{figure}


\subsection{Threading}
% Abstraction
% Structure (tree)
%% Main thread

To support concurrent programming fundamental mechanisms of threading has to be
supported. These include creating and destroying threads while also having
synchronization structures for mutual exclusion, such as mutexes.

We have done this by wrapping existing implementations of threading libraries.
This way we can easily change the threading back-end by choosing which library
wrapper to be compiled with the executable. The interface for threads will
therefor be the same, regardless of which library is handling the logic.

The thread interface is defines in {\tt thread.h}, while the back-ends will live
in {\tt thread\_<lib>.c}.

The abstract machine itself utilizes threading by always running programs
through threads. That way, all errors will safely be handled without crashing
the main process. This is paramount, as machine crashes are considered critical
errors and should never occur.

Threads will be structured in a tree fashion, where a thread can spawn multiple
child threads.
% TODO: update
\begin{ccode}
struct thread_state {
    struct thread_state *parent;
    struct thread_state *children;

    void *thread;

    uint32_t pc;
    stack_t stack;

    ...
};
\end{ccode}

As shown above, each thread state has a void pointer called {\tt thread}
(TODO). This is used by the chosen threading library, where itself needs to
create the necessary structures and track the data. This will likely consist of
some internal thread identifier and possible mutex variables.

\subsection{Types}
\input{implementation-types}
\subsection{Scopes}

\subsection{Binary file}

\subsection{Analysis}
% Valgrind
% gprof?

\subsection{Testing}
\input{implementation-testing}

% Assembler
%% Simple parsing/emitting
%% Label calculations (offsets)

% Object model
%% Virtual tables
%% (Un)boxing

% Execution model
%% Single stack
%% Return values as output arguments
%% No frame pointer(?)

% Binary format (ELF)
%% Sections
%% Type encoding
%% Instructions
%%% Argument encoding

% Exception handling

% Debugging information

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../report"
%%% End:
